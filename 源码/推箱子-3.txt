项目：推箱子
软件：JDK6,7 + Eclipse3.X
时间：11月4,6,8,10,12共计5天
------------------------------------------
2013年11月6日课程复习
1.人物制作
2.事件监听――键盘监听
3.人物移动控制

2013年11月8日课程内容
推箱子箱子(懒洋洋)制作、目的地(笼子)制作及障碍(树木)制作
整体方案模型设计
1.人物及其所有的东西放的位置一定要将窗体边缘的距离考虑进去
目前我的窗体中设置背景的位置是距离左边12，距离上面36，所以所有的组件
在添加时，必须加上这个修正值，如果不加就出现了无法对其的现象
横方向修正：12像素
纵方向修正：36像素

推箱子人物(灰太狼)位置调整
原始设计人物默认出现的位置在
lab_wolf.setBounds(300, 300, 50, 50);
经过修正后人物应该出现的位置是在下列位置
lab_wolf.setBounds(312, 336, 50, 50);

推箱子人物(灰太狼)移动控制调整
移动控制对应的坐标位置由于是动态获取的，因此不需要修改

推箱子箱子(懒洋洋)制作
按照人物的制作方式就可以制作出箱子的模型，这里图片不一样
1.创建图片，图片是羊的图片
Icon i = new ImageIcon("sheep-no.png");
2.使用JLabel组件模拟箱子模型
JLabel lab_sheep1 = new JLabel(i);
3.对箱子的位置进行设置，无论设置在什么位置，千万不能重复，横坐标是前面两个
整数(将偏移量考虑进去)
lab_sheep1.setBounds(312, 236, 50, 50);
4.箱子制作完毕后，将它添加到窗体中
this.add(lab_sheep1);
5.由于最终游戏中有多个箱子,3个箱子，因此要对上述过程进行重复制作
5.1图片是不需要重新制作了，因为所有箱子使用的是同样的图片
5.2多个箱子制作过程几乎完全相同，但是要使用不同的名称
	lab_sheep1   lab_sheep2   lab_sheep3
5.3多个箱子为了显示时不重叠，需要使用不同的坐标，同时不要与其他的东西重叠


推箱子目的地(笼子)制作
笼子的制作与羊的制作完全相同
Icon i = new ImageIcon("target.png");
JLabel lab_target1 = new JLabel(i);
lab_target1.setBounds(712, 236, 50, 50);
this.add(lab_target1);
注意：由于最终懒洋洋对应的显示效果应该是在笼子里面(后面),因此在组件添加时
一定要考虑让笼子的图片显示在羊的图片的上面，所以我们要对其进行位置的调整
1.先设定笼子
2.再设定羊和狼
3.最后设定背景


推箱子障碍(树木)制作
障碍制作方式分析
将障碍转换成一组数据，好多行数据，1的数据代表障碍，0的数据代表空地
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1
1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1
1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
障碍模型设计
上述模型实际上与JAVA语言中的二维数组模型完全一样
横着做多少？列
竖着做多少？行
背景图片多大？		800×600
每一个显示的内容多大？	50×50
横向可以显示的图片总数是：800÷50 = 16个
纵向可以显示的图片总数是：600÷50 = 12个
12行，16列
需要使用二维数组来模拟上述数据，12行16列
下面这个数组定义在class的大括号内
int[][] datas = {
		{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
		{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
		{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
		{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
		{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
		{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
		{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
		{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
		{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
		{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
		{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
		{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
	};

以下内容要制作到独立的障碍初始化的方法中，不要和上面的数组写到同样的地方
//1.创建图片
Icon ic = new ImageIcon("tree.png");
//遍历二维数组
for(int i = 0;i<datas.length;i++){
	for(int j = 0;j<datas[i].length;j++){
		//判断一下原始数据里面的值如果是1，做障碍
		if(datas[i][j] == 1){
		//障碍的初始化
		//2.创建JLabel
		JLabel lab_tree = new JLabel(ic);
		//3.设置大小位置
		lab_tree.setBounds(12+50*j,36+50*i,50,50);
		//4.添加到窗体中
		this.add(lab_tree);
		}
	}
}

场景更换
动态场景更换(思考)


























